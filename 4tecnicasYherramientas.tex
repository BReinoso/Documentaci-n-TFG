En este apartado se indicarán las técnicas y herramientas utilizadas durante la realización del proyecto.
\section{Técnicas de desarrollo}

En esta sección se indicarán las técnicas de desarrollo utilizadas a lo largo del proyecto.
\subsection{Metodología de desarrollo ágil}
Para llevar a cabo este proyecto hemos seguido una metodología ágil de desarrollo de proyectos. 

\paragraph{}El uso de una metodología ágil de desarrollo viene justificada por el hecho de que los datos respecto a los últimos años, la inmensa mayoría de los proyectos informáticos que se desarrollaron con una metodología clásica de gestión de proyectos han fracasado o no se han llegado a terminar. Ante este problema se ha ideado una nueva e innovadora metodología de gestión de proyectos, esta es llamada metodología de desarrollo ágil.

\paragraph{}La metodología de desarrollo ágil se tiene como objetivo el evitar el fracaso de los proyectos, para ello se pretende que los proyectos sigan un nuevo método de desarrollo llamado \textit{Scrum}. Las principales características del \textit{Scrum} son:
\begin{itemize}
	\item Adopta una estrategia de desarrollo incremental en contra partida a la ejecución completa del producto que se da en la gestión clásica de proyectos.
	\item Basa la calidad del resultado más en el conocimiento de las personas en equipos autoorganizados, que en la calidad de los procesos empleados a lo largo del proyecto.
	\item En el desarrollo ágil podemos observar un claro solapamiento de las fases de desarrollo, mientras que en la gestión clásica estas se producen de manera secuencial o en cascada.
\end{itemize}
Al usarse la metodología de desarrollo \textit{Scrum} podemos dividir el proceso en varias partes:
\begin{itemize}
	\item En primer lugar el desarrollo ha sido guiado a través de iteraciones, que han sido delimitadas como \textit{Sprints}. Estos \textit{Spints} tienen una duración de entre 1 o 2 semanas.
	\item En cada \textit{Sprint} se propone una serie de tareas y objetivos a completar antes de la finalización del mismo.
	\item Al final de cada \textit{Sprint} se ha realizado una reunión en la que se establecía los objetivos que se han cumplido en ese \textit{Sprint}, esto ha sido reflejado en la planificación del proyecto como \textit{Retrospective Meeting}; seguidamente se proponía los nuevos objetivos para el siguiente \textit{Sprint}, esto esta representado en la planificación del proyecto como \textit{Sprint planning}.
\end{itemize}
\paragraph{}Creemos que gracias al uso de este tipo de metodología el proyecto tiene mayores posibilidades de terminar de manera exitosa.
\subsection{Desarrollo Software con control de versiones}
El control de versiones en desarrollo software se puede describir como la gestión de los cambios que se producen en nuestro software o en la configuración del mismo. Entendiéndose como versión el estado en el que se encuentra el software en un determinado momento.
\paragraph{}En el proyecto se ha usado el control de versiones sobre el software a programar por parte del alumno. Para realizar el control de versiones se ha creado un repositorio público en \href{https://github.com/}{GitHub}.
\paragraph{}En \href{https://github.com/}{GitHub} las versiones se van determinando a través de \textit{commits}. Lo \textit{commits} son una actualización del estado actual del proyecto, estas actualizaciones llevan un título y un comentario para poder identificar los cambios del software y qué documentos han sido añadidos en qué \textit{commit}.
\paragraph{}En el proyecto la asiduidad de los \textit{commits} no sigue ningún procedimiento estricto, sino que cuando se determinará que se ha producido un cambio en el software lo suficientemente importante se realizaría un \textit{commit} con un comentario descriptivo del cambio que se ha producido en el software.
\paragraph{}Lo interesante del uso de este tipo de metodología junto con la herramienta es que se pueden extraer gráficos y datos que nos aportan información bastante representativa de cómo ha ido evolucionando el proyecto en el aspecto software. También nos asegura que los cambios realizados no se pierden en caso de que la máquina falle o en caso de habernos equivocado al hacer un \textit{commit} este puede ser deshecho.
En conclusión el uso de control de versiones aporta muchas ventajas y datos con los que posteriormente podremos analizar más en profundidad la evolución del proyecto y usarlo como \textit{feedback} para posteriores proyectos que se vayan a realizar.
\section{Herramientas utilizadas}

En este apartado se mostrará las distintas herramientas utilizadas para el desarrollo del proyecto.

\subsection{Gestor de Tareas: VersionOne}
Se ha estudiado entre varias posibles herramientas, entre ellas están:
\begin{itemize}
    \item \href{http://www.pivotaltracker.com/}{PivotalTracker}
    \item \href{https://www.fogcreek.com/FogBugz/}{FogBugz}
    \item \href{http://www.versionone.com/}{VersionOne}
\end{itemize}
\paragraph{}Se ha optado por la herramienta VersionOne, que ofrece unas condiciones notablemente mejores a las otras en su versión gratuita y además resulta bastante intuitiva y fácil de usar.

Con esta herramienta nos encargaremos de generar los Sprints del proyecto y se gestionará las tareas dentro de cada uno. Esta herramienta es usada en el desarrollo ágil, que es el tipo de desarrollo que se llevará acabo en el proyecto, además de que con la herramienta podemos, posteriormente, generar una serie de gráficos e informes que nos serán de gran ayuda a la hora de documentar el proyecto y de gestionar el avance del mismo.

\subsection{Gestor de Versiones: Git Hub}

Se ha estudiado entre varias posibles herramientas, entre ellas están:
\begin{itemize}
    \item \href{https://github.com/}{GitHub}
    \item \href{https://bitbucket.org/}{Bitbucket}
    \item \href{http://sourceforge.net/}{Sourcefroge}
\end{itemize}
\paragraph{}Finalmente se decidió que se iba a usar la herramienta GitHub porque se tenía experiencia previa en el uso de la misma, ofrece unas condiciones bastante razonables en su versión gratuita y se puede hace un buen seguimiento del proyecto con ella.
Además de que es bastante sencilla la generación de commits en Windows porque dispone de una aplicación con la que lo commits se realizan de manera sencilla. Se puede ver de una manera bastante clara cómo ha ido avanzando el proyecto y se puede extraer unos gráficos muy útiles a la hora de documentar y determinar cómo ha avanzado el proyecto.
Además al estar en su versión gratuita los miembros del jurado y cualquier persona que desee el acceso al proyecto sólo necesitará el link del mismo para poder verlo y comprobar la asiduidad de los commits y cómo ha sido la evolución del proyecto.
\subsection{IDEL de desarrollo: Android Studio}
Se ha estudiado entre varias posibles herramientas, entre ellas están:
\begin{itemize}
    \item \href{https://eclipse.org/}{Eclipse}
    \item \href{http://developer.android.com/sdk/index.html}{Android Studio}
\end{itemize}
\paragraph{}La elección de Android Studio ha sido porque no sólo es una herramienta exclusivamente dedicada a aplicaciones Android, sino que resultaba más prometedora que Eclipse; la cuál pensamos que puede quedar obsoleta para este tipo de aplicaciones.
También vemos que Android Studio ofrece un gestor de instalación de paquetes de kit de desarrollo y plugins, lo cuál puede resultar muy útil a la hora de la configuración del entorno de desarrollo. Además en Android Studio no puede sólo usarse máquinas virtuales de móviles, sino que puedes conectar un dispositivo móvil al ordenador e ir ejecutando tu aplicación sobre el contando con un debugger y un logcat para errores, lo cual facilita en gran medida la programación.

\subsection{Herramienta de Generación de Documentación: \LaTeX}
Se ha elegido esta herramienta debido a su facilidad de uso y a que optimiza automáticamente la estructura del producto final para ofrecer el mejor resultado visual. También prevemos que el uso de esta herramienta facilitará en gran medida la carga de trabajo al realizar la documentación lo que permitirá ahorrarse tiempo en este apartado, producir un resultado mas eficiente y bueno y, finalmente, se podrá usar el tiempo ahorrado en otras cosas para el avance del proyecto.

\subsection{Herramientas de Deep Learning: NeuralTalk}

Se ha estudiado entre varias posibles herramientas, entre ellas están:
\begin{itemize}
    \item \href{http://libccv.org/post/with-a-sub-10-image-classifier-a-decent-face-detector-here-comes-ccv-0.7/}{Lib CCV}
    \item \href{http://cs.stanford.edu/people/karpathy/rcnn/}{Overfeat}
    \item \href{https://github.com/jetpacapp/DeepBeliefSDK}{Deep Belief SDK}
\end{itemize}
\paragraph{}Esta herramienta ha sido elegida porque venía en el mismo idioma en el que se iba a programar el servidor, además de que su aplicación en nuestro proyecto era mucho mas práctico, pues devuelve una frase descriptiva de lo que en una imagen hay.
Lamentablemente su funcionamiento e instalación son algo enrevesadas y requiere de una configuración que  depende mucho de la máquina en la que se trabaje y de la estructura de directorios que esta tenga, pero una vez configurada su funcionamiento es el esperado.

\subsection{Herramientas de Deep Learning: Caffe}

Esta herramienta es usada en nuestro proyecto debido a que la herramienta NeuralTalk tiene dependencia de este proyecto para extraer características de las imágenes y luego poder realizar una predicción con ellas.
Además este proyecto está bien estructurado y en si se sigue correctamente su documentación es relativamente fácil de instalar.
Caffe es un arquitectura para el \textit{deep learning} que está programada en C++ puro y en CUDA, pero también se puede usar en línea de comandos en un sistema Unix y cuenta con \textit{wrappers} para Python y MATLAB.
Sus principales características que lo convierten en un proyecto que destaca sobre los demás son:
\begin{itemize}
	\item Es una arquitectura que funciona de manera especialmente rápida.
	\item Su código está bien testeado.
	\item Tiene buenas herramientas, modelos de referencia, demos y repositorios.
	\item Posibilidad de ejecutarlo tanto en CPU como en GPU
\end{itemize}
\subsubsection{Anatomía de un modelo Caffe}
La \textit{deep networks} o redes profundas son modelos compositivos que se representand e forma natural como un conjunto o una colección de capas interconectadas que trabajan sobre fragmentos de datos. Caffe define una red capa a capa en su propio esquema de modelo. La red define el modelo entero desde abajo hasta arriba a partir de unos datos de entrada. Como los datos y sus derivados fluyen a través de la red en el \textit{Forward and Backward}, Caffe guarda, comunica y manipula la información como burbujas: la burbuja es una matriz estándar y una interfaz de memoria unificada para el \textit{framework}. La capa que sigue es tratada como la base tanto del modelo como de la computación. La red se considera como un conjunto de capas y de sus intercionexiones. Los detalles dentro de cada burbuja describen como la información será guardada y cómo esta será enviada a través de las distintas capas y redes.

\paragraph{}La forma en que se resuelve la predicción es configurada a parte para desacoplar el modelo de la optimización del mismo.

\subsection{Herramientas de programación: MATLAB}

Tuvimos que instalar MATLAB porque NeuralTalk usa un script de MATLAB para poder preparar las imágenes para extraerles las características, además se usa el wrapper de caffe para MATLAB.

\subsection{Herramientas de desarrollo de servidores: Flask}

Se ha estudiado entre varias posibles herramientas, entre ellas están:
\begin{itemize}
    \item \href{http://axis.apache.org/axis2/c/core/}{Axis2/C}
    \item \href{http://www.cs.fsu.edu/~engelen/soap.html}{GSOAP}
    \item \href{http://tomcat.apache.org/}{Tomcat}
\end{itemize}
\paragraph{}Se ha escogido esta herramienta en concreto porque sobre todas las demás su funcionamiento era muy inmediato y además se escribe en Python, que es un idioma muy versátil y fácil de usar. El hecho de que esta herramienta tenga un funcionamiento y programación tan sencilla la hace una herramienta que, a nuestro parecer, destaca sobre el resto y es interesante trabajar con ella.
Además tiene una documentación sencilla, repleta de ejemplos y explicaciones para poder realizar tu servidor. Sus ejemplos son muy útiles y funcionan a la primera, sin tener que configurar casi nada. Tiene una forma de establecer los URLs de forma muy sencilla y es fácil estructurar tu servidor con esta API.
A pesar de ser una API tan fácil de usar tiene una gran potencia y se pueden construir con ella servidores bastante grandes y fácilmente escalables, por tanto se convierte en la herramienta perfecta para la programación de nuestro servidor.

\subsection{Librería Text2Speech para Android}

\subsection{Librería de Apache para conexiones Http para Android}

\subsection{Librería de Google para la traducción de texto}