En este capítulo se indicarán las técnicas y herramientas utilizadas durante la realización del proyecto.
\section{Técnicas de desarrollo}

En esta sección se indicarán las técnicas de desarrollo utilizadas a lo largo del proyecto.
\subsection{Metodología de desarrollo ágil}
Para llevar a cabo este proyecto hemos seguido una metodología ágil de desarrollo de proyectos. 

El uso de una metodología ágil de desarrollo viene justificada por el hecho de que los datos respecto a los últimos años, la inmensa mayoría de los proyectos informáticos que se desarrollaron con una metodología clásica de gestión de proyectos han fracasado o no se han llegado a terminar. Ante este problema, se ha ideado una nueva e innovadora metodología de gestión de proyectos, esta es llamada metodología de desarrollo ágil.

La metodología de desarrollo ágil tiene como objetivo el evitar el fracaso de los proyectos, para ello se pretende que los proyectos sigan un nuevo método de desarrollo llamado \textit{Scrum}. Las principales características del \textit{Scrum} \cite{schwaber2004agile} son:
\begin{itemize}
	\item Adopta una estrategia de desarrollo incremental en contra partida a la ejecución completa del producto que se da en la gestión clásica de proyectos.
	\item Basa la calidad del resultado más en el conocimiento de las personas en equipos autoorganizados, que en la calidad de los procesos empleados a lo largo del proyecto.
	\item En el desarrollo ágil podemos observar un claro solapamiento de las fases de desarrollo, mientras que en la gestión clásica estas se producen de manera secuencial o en cascada.
\end{itemize}
Al usarse la metodología de desarrollo \textit{Scrum} podemos dividir el proceso en varias partes:
\begin{itemize}
	\item En primer lugar el desarrollo ha sido guiado a través de iteraciones, que han sido delimitadas como \textit{Sprints}. Estos \textit{Sprints} tienen una duración de entre 1 o 2 semanas.
	\item En cada \textit{Sprint} se propone una serie de tareas y objetivos a completar antes de la finalización del mismo.
	\item Al final de cada \textit{Sprint} se ha realizado una reunión en la que se establecía los objetivos que se han cumplido en ese \textit{Sprint}, esto ha sido reflejado en la planificación del proyecto como \textit{Retrospective Meeting}; seguidamente se proponía los nuevos objetivos para el siguiente \textit{Sprint}, esto está representado en la planificación del proyecto como \textit{Sprint planning}.
\end{itemize}
\paragraph{}Creemos que gracias al uso de este tipo de metodología el proyecto tiene mayores posibilidades de terminar de manera exitosa.
\subsection{Desarrollo software con control de versiones}
El control de versiones en desarrollo software se puede describir como la gestión de los cambios que se producen en nuestro software o en la configuración del mismo. Entendiéndose como versión el estado en el que se encuentra el software en un determinado momento.

En el proyecto se ha usado el control de versiones sobre el software a programar por parte del alumno. Para realizar el control de versiones se ha creado un repositorio público en GitHub\footnote{\label{note1}\url{https://github.com/garfio1/Proyecto-Fin-de-Grado}}.
\paragraph{}En GitHub las versiones se van determinando a través de \textit{commits}. Lo \textit{commits} son una actualización del estado actual del proyecto, estas actualizaciones llevan un título y un comentario para poder identificar los cambios del software y qué documentos han sido añadidos en qué \textit{commit}.

En el proyecto la asiduidad de los \textit{commits} no sigue ninguna pauta, sino que simplemente  cuando se determina que se ha producido un cambio en el software lo suficientemente importante, se realizaría un \textit{commit} con un comentario descriptivo del cambio que se ha producido.

Lo interesante del uso de este tipo de metodología, junto con la herramienta, es que se pueden extraer gráficos y datos que nos aportan información bastante representativa de cómo ha ido evolucionando el proyecto en el aspecto software. También nos asegura que los cambios realizados no se pierden en caso de que la máquina falle, o en caso de habernos equivocado al hacer un \textit{commit} este puede ser deshecho.

En conclusión el uso de control de versiones aporta muchas ventajas y datos con los que posteriormente podremos analizar más en profundidad la evolución del proyecto y usarlo como \textit{feedback} para posteriores proyectos que se vayan a realizar.
\section{Herramientas utilizadas}

En este apartado se mostrarán las distintas herramientas utilizadas para el desarrollo del proyecto.

\subsection{Gestor de Tareas: VersionOne}
Se han estudiado varias posibles herramientas, entre ellas están:
\begin{itemize}
    \item \textbf{PivotalTracker}\footnote{\url{http://www.pivotaltracker.com/}}
    \item \textbf{FogBugz}\footnote{\url{https://www.fogcreek.com/FogBugz/}}
    \item \textbf{VersionOne}\footnote{\label{note2}\url{http://www.versionone.com/}}
\end{itemize}

Se ha optó por la herramienta VersionOne\footnoteref{note2}, que a priori ofrecía unas condiciones notablemente mejores a las otras en su versión gratuita y además resulta bastante intuitiva y fácil de usar.

Con esta herramienta nos encargaremos de generar los Sprints del proyecto y se gestionarán las tareas dentro de cada uno. Esta herramienta es usada en el desarrollo ágil, que es el tipo de desarrollo que se llevará acabo en el proyecto, además de que con la herramienta podemos, posteriormente, generar una serie de gráficos e informes que nos serán de gran ayuda a la hora de documentar el proyecto y de gestionar el avance del mismo.

\subsection{Gestor de Versiones: GitHub}

Se han estudiado varias posibles herramientas, entre ellas están:
\begin{itemize}
    \item \textbf{GitHub}\footnoteref{note1}
    \item \textbf{Bitbucket}\footnote{\url{https://bitbucket.org/}}
    \item \textbf{Sourcefroge}\footnote{\url{http://sourceforge.net/}}
\end{itemize}
\paragraph{}Finalmente se decidió que se iba a usar la herramienta GitHub\footnoteref{note1} porque se tenía experiencia previa en el uso de la misma, ofrece unas condiciones bastante razonables en su versión gratuita y se puede hacer un buen seguimiento del proyecto con ella.
Además de que es bastante sencilla la generación de commits en Windows, porque dispone de una aplicación con la que \textit{commits} se realizan de manera sencilla. Se puede ver de una manera bastante clara cómo ha ido avanzando el proyecto y se pueden extraer unos gráficos muy útiles a la hora de documentar y determinar cómo ha avanzado el proyecto.
Además al estar en su versión gratuita, los miembros del jurado y cualquier persona que desee el acceso al proyecto sólo necesitará el link del mismo para poder verlo y comprobar la asiduidad de los \textit{commits} y cómo ha sido la evolución del proyecto (\url{https://github.com/garfio1/Proyecto-Fin-de-Grado}).
\subsection{IDE de desarrollo: Android Studio}
Se han estudiado varias posibles herramientas, entre ellas están:
\begin{itemize}
    \item \textbf{Eclipse}\footnote{\url{https://eclipse.org/}}
    \item \textbf{Android Studio}\footnote{\label{note3}\url{http://developer.android.com/sdk/index.html}}
\end{itemize}
\paragraph{}La elección de Android Studio\footnoteref{note3} ha sido porque no sólo es una herramienta exclusivamente dedicada a aplicaciones Android, sino que resultaba más prometedora que Eclipse; la cuál pensamos que puede quedar obsoleta para este tipo de aplicaciones.
También vemos que Android Studio\footnoteref{note3} ofrece un gestor de instalación de paquetes de \textit{kit} de desarrollo y \textit{plugins}, lo cuál puede resultar muy útil a la hora de la configuración del entorno de desarrollo. Además, en Android Studio\footnoteref{note3} no puede sólo usarse máquinas virtuales de móviles, sino que se puede conectar un dispositivo móvil al ordenador e ir ejecutando tu aplicación sobre el contando con un depurador y un \textit{logcat} para errores, lo cual facilita en gran medida la programación.

\subsection{Herramienta de Generación de Documentación: \TeX Maker}
Esta herramienta ha sido elegida por su interfaz gráfica, la cual es muy intuitiva y fácil de usar. Además de que es muy fácil de instalar y tiene ayuda en todo momento, pues autocompleta las etiquetas que se quiera usar y las referencias. Además, su consola de errores ayuda en gran medida a la hora de encontrar errores en los documentos. También permite el uso de proyectos con más de un documento de tipo \TeX{}, dando la opción de marcar uno de ellos como documento maestro.

Por debajo esta herramienta esta usando \LaTeX , que es un sistema para preparar documentos de manera sencilla y fácil. El objetivo de este sistema es que nosotros nos concentremos en escribir el contenido de manera adecuada y que no se nos olvide ningún detalle, dejando a \LaTeX{} que se encargue de optimizar el documento para que tenga la presentación más óptima y adecuada.

En conclusión, sin duda este tipo de sistema y herramienta es uno de los más adecuados para el trabajo que vamos a realizar.

\subsection{Herramientas de Deep Learning: NeuralTalk}

Se han estudiado varias posibles herramientas, entre ellas están:
\begin{itemize}
    \item \textbf{Lib CCV}\footnote{\url{http://libccv.org/post/with-a-sub-10-image-classifier-a-decent-face-detector-here-comes-ccv-0.7/}}
    \item \textbf{Overfeat}\footnote{\url{http://cs.stanford.edu/people/karpathy/rcnn/}}
    \item \textbf{Deep Belief SDK}\footnote{\label{note4}\url{https://github.com/jetpacapp/DeepBeliefSDK}}
\end{itemize}

Esta herramienta, NeuralTalk, ha sido elegida porque venía en el mismo idioma en el que se iba a programar el servidor, además de que su aplicación en nuestro proyecto era mucho mas práctica, pues devuelve una frase descriptiva de lo que en una imagen hay.
Lamentablemente, su funcionamiento e instalación son algo enrevesadas y requiere de una configuración que  depende mucho de la máquina en la que se trabaje y de la estructura de directorios que esta tenga, pero una vez configurada su funcionamiento es el esperado.

Aunque cabe destacar que se uso la herramienta DeepBeliefSDK\footnoteref{note4} en gran parte del proyecto, puesto que sus pruebas fueron correctas y funcionaba de manera bastante adecuada. Pero finalmente desistimos de su uso como herramienta principal debido a que al intentar combinarlo con la herramienta GSOAP\footnote{\label{note5}\url{http://www.cs.fsu.edu/~engelen/soap.html}}, acabo no teniendo un correcto funcionamiento debido a que el módulo de GSOAP\footnoteref{note5} para Apache no era bueno y su documentación bastante floja. Esto está explicado de forma mucho más detallada en el apartado de Aspectos Relevantes (\ref{subchap:RelevGSOAP}).

\subsection{Herramientas de Deep Learning: Caffe}
Esta herramienta \cite{jia2014caffe} es usada en nuestro proyecto debido a que la herramienta NeuralTalk tiene dependencia de este proyecto para extraer características de las imágenes y luego poder realizar una predicción con ellas.
Además este proyecto está bien estructurado y, si se sigue correctamente su documentación, es relativamente fácil de instalar.

Caffe es un arquitectura para el \textit{Deep Learning} que está programada en C++ puro y en CUDA, pero también se puede usar en línea de comandos en un sistema Unix y cuenta con \textit{wrappers} para Python y MATLAB.
Sus principales características que lo convierten en un proyecto que destaca sobre los demás son:
\begin{itemize}
	\item Es una arquitectura que funciona de manera especialmente rápida.
	\item Su código está bien testeado.
	\item Tiene buenas herramientas, modelos de referencia, demos y repositorios.
	\item Posibilidad de ejecutarlo tanto en CPU como en GPU
\end{itemize}
\subsubsection{Anatomía de un modelo Caffe}
Las \textit{deep networks} o redes profundas son modelos compositivos que se representan de forma natural como un conjunto o una colección de capas interconectadas que trabajan sobre fragmentos de datos. Caffe define una red capa a capa en su propio esquema de modelo. La red define el modelo entero desde abajo hasta arriba a partir de unos datos de entrada. Como los datos y sus derivados fluyen a través de la red en el \textit{Forward and Backward}, Caffe guarda, comunica y manipula la información como burbujas: la burbuja es una matriz estándar y una interfaz de memoria unificada para el \textit{framework}. La capa que sigue es tratada como la base tanto del modelo como de la computación. La red se considera como un conjunto de capas y de sus intercionexiones. Los detalles dentro de cada burbuja describen como la información será guardada y cómo esta será enviada a través de las distintas capas y redes.

\paragraph{}La forma en que se resuelve la predicción es configurada a parte para desacoplar el modelo de la optimización del mismo.

\subsection{Herramientas de programación: MATLAB}

Tuvimos que instalar MATLAB porque NeuralTalk usa un script de MATLAB para poder preparar las imágenes para extraerles las características, además se usa el wrapper de caffe para MATLAB.

\subsection{Herramientas de desarrollo de servidores: Flask}

Se han estudiado varias posibles herramientas, entre ellas están:
\begin{itemize}
    \item \textbf{Axis2/C}\footnote{\url{http://axis.apache.org/axis2/c/core/}}
    \item \textbf{GSOAP}\footnoteref{note5}
    \item \textbf{Tomcat}\footnote{\url{http://tomcat.apache.org/}}
\end{itemize}

Se ha escogido Flask en concreto porque sobre todas las demás su funcionamiento era muy inmediato y además se escribe en Python, que es un lenguaje de programación muy versátil y fácil de usar. El hecho de que esta herramienta tenga un funcionamiento y programación tan sencilla la hace una herramienta que, a nuestro parecer, destaca sobre el resto y es interesante trabajar con ella.
Además tiene una documentación sencilla, repleta de ejemplos y explicaciones para poder realizar tu servidor. Sus ejemplos son muy útiles y funcionan a la primera, sin tener que configurar casi nada. Tiene una forma de establecer los URLs de forma muy sencilla y es fácil estructurar tu servidor con esta API.
A pesar de ser una API tan fácil de usar tiene una gran potencia y se pueden construir con ella servidores bastante grandes y fácilmente escalables, por tanto se convierte en la herramienta perfecta para la programación de nuestro servidor.

\subsection{Biblioteca Text to Speech para Android}
En nuestra aplicación cliente hemos usado la biblioteca \textit{Text to Speech} que nos ofrece Android para realizar la lectura de mensajes para el cliente.

El funcionamiento de este tipo de bibliotecas es parecido, se trata de un problema de procesadores de lenguajes. Primero se analiza la entrada a través de una serie de reglas para acabar asociando estas a unos sonidos de salida, estos acabarán constituyendo el clip de audio con la frase esperada. Esto se puede ver explicado de forma más detallado en el apartado de Conceptos Teóricos (ver \ref{ConTeoTTS}). 
\subsection{Biblioteca de Apache para conexiones Http para Android}
Para establecer la conexión con el Servidor se ha usado la biblioteca de Apache, que nos permite establecer una conexión con un servidor, a través del protocolo HTTP, de manera muy sencilla.

Se ha usado este tipo de biblioteca debido a que el servicio web que se va ha programar usa el estándar REST para aportar los servicios y realizar el intercambio de datos con los distintos clientes que se conecten a este. Este tipo de conexión y la explicación de servicio web se puede ver más detallada en el apartado de conceptos teóricos (ver \ref{ConTeoServicioWeb}).

Esta biblioteca tiene una serie de elementos que se utilizan dentro de la aplicación Android para que todo funcione de manera correcta, los elementos son los siguientes:
\begin{itemize}
	\item \cmd{HttpClient}: Este objeto se usa para establecer el cliente que ejecutará la petición. Es un objeto que te representa como cliente que se conecta al servidor.
	\item \cmd{HttPost}: Este objeto está hecho para determinar el tipo de operación que se va a solicitar al servicio web, en este caso es del tipo POST. Este objeto llevará asociada una cabecera con la que se establece la conexión.
	\item \cmd{MultipartEntityBuilder}: Este objeto maneja los datos que queremos enviar con nuestra petición, en nuestro caso será una imagen. Después de haberle añadido los datos a este objeto, podemos crear a partir de él un objeto de tipo \cmd{HttpEntity}.
	\item \cmd{HttpEntity}: Este objeto es una entidad que lo que realmente tiene en su interior es la parte de la cabecera de la petición donde van definidos los datos, osea los metadatos de la cabecera de una petición HTTP.
	\item \cmd{HttpResponse}: En este objeto recibimos la respuesta que el servidor nos da tras ejecutar la operación que hayamos definido. 
\end{itemize}
Como nota final cabe destacar que el procesamiento de todo esto deber hacerse en un hilo separado del hilo principal de ejecución de la aplicación debido a que los estándares de Android así lo establecen.
\subsection{Biblioteca de traducción de texto}
En el lado del servidor se procede al uso de una biblioteca de traducción porque la herramientas nos devuelven las cadenas sen inglés, pero nosotros las queremos en español.

En un principio se optó por intentar usar la biblioteca de Google para la traducción de texto, pero nos encontramos con el inconveniente de que esta era de pago. Entonces, ante la búsqueda de una solución, se procedió a usar un proceso algo mas rudimentario pero igualmente válido. Como no se tenía acceso a una API de traducción se usaron los conceptos aprendidos de servicio web y de sus peticiones para simular una conexión a la página de traducción de Google y recibir de ella la cadena traducida.

El  resultado se obtiene en un tipo de dato json pero este es fácilmente convertible a texto y de ahí se extrae la cadena ya traducida.